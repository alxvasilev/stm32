<html>
<head>
<style>

.glyph {
    display: inline-block;
    float: left;
    vertical-align: top;
}
#main {
    display: flex;
    flex-flow: row;
}
#menu {
    display: flex;
    flex-flow: row;
    border-bottom: 1px solid #eeeeee;
    flex: 0 0 40px;
}
#pageDiv {
    display: flex;
    flex-flow: column;
    height: 100%;
    user-select: none;
    cursor: default;
}
#editorGroup {
    flex: 0 0 auto;
    display: flex;
    flex-flow: column
}
#editor {
   flex: 0 0 auto;
   border: 1px solid #eeeeee
}
#typingArea {
    flex: 0 0 auto;
    border: 1px solid #eeeeee
}
#lcd {
 height: 128px;
 width:256px;
 background: linear-gradient(to bottom, #f1f7de 0%,#cfd9b0 100%);
 overflow: hidden;
}

#glyphs {
    flex: 1 1 auto;
    display: flex;
    flex-flow: row;
    flex-wrap: wrap;
    align-self: stretch;
    overflow: auto;
    border-left: 1px solid #eeeeee;
}
#spacer {
    flex: 0 0 10px;
}
.glyph {
    flex: 0 0 auto;
    border-right: 1px solid #eeeeee;
    border-bottom: 1px solid #eeeeee;
}
.openCaption {
    text-align: center;
    font-size: 44px;
    flex: 0 0 auto;
    padding-top: 15px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eeeeee;
}

.openBtnPanel {
    flex: 0 0 auto;
    display: flex;
    flex-flow: row;
}

.openModeSection {
    flex: 1 1 50%;
    flex-flow: column;
    justify-content: space-around;
}

.openBtn {
    flex: 0 0 auto;
    align-self: center;
    text-align: center;
    border-radius: 8px;
    border: 2px solid #eeeeee;
    padding: 10px;
    cursor: hand;
    font-size: 20px;
}
.openBtn:hover {
    background: lightblue;
}
.openOptions {
    flex: 0 0 auto;
    align-self: center;
    display: flex;
    flex-flow: column;
}
.fontSelect {
    flex: 0 0 auto;
    align-self: center;
}
.borderBottomRight {
   border-bottom: 1px solid #eeeeee;
   border-right: 1px solid #eeeeee;
}
</style>
</head>
<body id=page>
</body>
<script language=javascript>
const kColorFg = "black";
const kColorBg = "white";
var blackThresh = 190;
var borderBlackThresh = 210;
function GlyphModel(w, h)
{
    this.width = w;
    this.height = h;
    this.rows = new Array(h);
    for (var r=0; r<h; r++) {
        var row = this.rows[r] = new Array(w);
        for (var c=0; c<w; c++) {
           row[c] = false;
        }
    }
    this.listeners = new Array();
}

GlyphModel.prototype.flip = function(x, y) {
    var row = this.rows[y];
    var val = row[x] = !row[x];
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].updatePixel(x, y, val);
    }
}
GlyphModel.prototype.set = function(x,y,val) {
    var row = this.rows[y];
    var oldVal = row[x];
    if (val === oldVal)
        return;
    row[x] = val;
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].updatePixel(x, y, val);
    }
}

GlyphModel.prototype.addListener = function(obj) {
    this.listeners.push(obj);
}
GlyphModel.prototype.removeListener = function(obj) {
    var idx = this.listeners.indexOf(obj);
    if (idx < 0)
        return false;
    this.listeners.splice(idx, 1);
    return true;
}
GlyphModel.prototype.loadFromImgData = function(data) {
    var w = data.width;
    var h = data.height;
    if (w != this.width || h != this.height)
        throw new Error("Canvas has dimmentions different than these of the model");
    data = data.data;
    for (var r = 0; r<h; r++) {
        var row = this.rows[r];
        for (var x = 0; x<w; x++) {
            row[x] = data[(r*w+x)*4] < blackThresh;
        }
    }
}
var gDragged = null;

function GlyphView(model, psize, opts)
{
    var self = this;
    self.model = model;
    self.fg = opts.fg || kColorFg;
    self.bg = opts.bg || kColorBg;
    var view = self.widget = document.createElement('table');
    view.style.borderSpacing = 0;
    var rows = model.rows;
    var rowCnt = rows.length;
    var colCnt = rows[0].length;
    var palette = opts.palette ? opts.palette : null;
    for (var y = 0; y < rowCnt; y++) {
        var row = view.insertRow(-1);
        row.style.height=psize;
        var rowData = model.rows[y];
        for (var x = 0; x < colCnt; x++) {
            var cell = row.insertCell(-1);
            var cellData = rowData[x];
            var style = cell.style;
            style.width=psize;
            if (palette) {
                style.backgroundColor = palette[cellData];
            } else {
                style.backgroundColor = cellData ? self.fg : self.bg;
            }
            style.padding = 0;
            var border = opts.border;
            if (border === true) {
                style.border = '1px solid #eeeeee';
            } else if (border) {
                style.border = border;
            } else {
                style.border = '0px';
            }
            cell.x = x;
            cell.y = y;
            if (opts.active) {
                cell.onclick = function(event) {
                    var c = event.target;
                    self.model.flip(c.x,c.y);
                }
                cell.ondragstart = function(event) {
                    // store a ref. on the dragged elem
                    gDragged = event.target;
                    // make it half transparent
                };
                cell.ondragover = function(event) {
                    if (!gDragged)
                        return;
                    var val = (gDragged.style.backgroundColor === self.bg) ? 0 : 1;
                    var target = event.target;
                    self.model.set(target.x, target.y, val);
                }
            }
        }
    }
    model.addListener(self);
}

GlyphView.prototype.updatePixel = function(x,y,val) {
    var row = this.widget.rows[y];
    row.cells[x].style.backgroundColor = val ? this.fg : this.bg;
}

GlyphView.prototype.changeModel = function(model) {
    this.model.removeListener(this);
    this.model = model;
    var h = this.widget.rows.length;
    var w = this.widget.rows[0].cells.length;
    if (h !== model.height || w !== model.width) {
        throw new Error("changeModel: new model has different dimensions");
    }
    for (var y = 0; y < h; y++) {
        var row = this.widget.rows[y];
        var rowData = model.rows[y];
        for (var x = 0; x < w; x++) {
            row.cells[x].style.backgroundColor = rowData[x] ? kColorFg : kColorBg;
        }
    }
    model.addListener(this);
}

var glyphs = [];
var lcdLetters = [];
var fontWidth = 8;
var fontHeight = 10;

var gEditor = null;
var glyphCont = null;
var editorHtml =
"<div id=pageDiv>\
   <div id=menu>menu</div>\
   <div id=main>\
     <div id=editorGroup>\
       <div id=editor></div>\
       <div align=center>LCD preview:</div>\
       <div style='position:relative'>\
       <div id=lcd></div>\
       </div>\
       <textarea id=typingArea></textarea>\
     </div>\
   <div id= spacer></div>\
   <div id= glyphs></div>\
 </div>\
</div>";

var loadGui =
"<div id=pageDiv>\
  <div class=openCaption>Load font:</div>\
  <div style='flex: 0 0 10%'> </div>\
  <table width=100%>\
    <tr>\
      <td style='width:50%'>\
        <div class=openBtn>From file</div></td>\
      <td style='width:50%'>\
        <div class=openBtn onclick='fontSelectGui();'>Capture</div>\
      </td>\
    </tr>\
    <tr>\
      <td><div></div>\
      <td><div id=captureOptions class=openOptions></div>\
    </tr>\
  </table>";

function loadEditor() {
    document.getElementById('page').innerHTML = editorHtml;
    glyphCont = document.getElementById('glyphs');
    var glyphCount = 200;
    for (var i = 0; i < glyphCount; i++) {
        var model = new GlyphModel(8,8);
        var view = new GlyphView(model, 8, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = view.widget;
        widget.model = model; //make the model accessible from the onclick handler
        widget.className = 'glyph';
        glyphs.push(model);
        glyphCont.appendChild(view.widget);
        view.widget.onclick = function(event) {
        gEditor.changeModel(event.currentTarget.model);
        }
    }
    gEditor = new GlyphView(glyphs[0], 32, {active: true});
    document.getElementById('editor').appendChild(gEditor.widget);
    var txtInput = document.getElementById('typingArea');
    txtInput.onkeypress = function(event) {
        var idx = event.charCode - 32;
        if (idx < 0 || idx >= glyphs.length)
            return;
        var model = glyphs[0]; //[idx];
        var letter = new GlyphView(model, 2, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = letter.widget;
        widget.style.display = "inline-block";
        lcd.appendChild(letter.widget);
   }
   txtInput.onkeydown = function(event) {
       if (event.keyCode === 8) { //backspace
           var child = lcd.lastChild;
           if (child)
               lcd.removeChild(child);
           return;
       }
   }
}

function fontOpenGui() {
    document.getElementById("page").innerHTML = loadGui;
}

var standardFonts = ['arial', 'serif', 'sans-serif', 'monospace', 'Monaco, Lucida Console, monospace'];
/*
//Sans serif
'Arial, 'Arial Black', 'Tahoma', 'Trebuchet MS',
'Century Gothic', 'Geneva', 'Lucida','Lucida Sans', 'Lucida Grande',
//Serif
'Georgia', 'Times', 'Times New Roman',
'MS Serif', 'New York', 'Palatino', 'Palatino Linotype', 'Verdana',
//monospace
'Courier', 'Courier New', 'Lucida Console', 'Monaco'
*/

function fontSelectGui() {
   var cont = document.getElementById('captureOptions');
   while (cont.firstChild)
       cont.removeChild(cont.firstChild);
   cont.innerHTML =
   "<table width=100% style='table-layout:fixed'>\
   <tr>\
       <td id=localFont width=50% class=borderBottomRight></td>\
       <td id=remoteFont width=50% class=borderBottomRight></td></tr>\
   <tr><td colspan=2>\
        <table width=100%>\
         <tr>\
          <td><canvas id=capture style='border: 1px solid #0000ff;\
           width:200; height: 200; align-senf: center' /></td>\
           <td id=glyph></td>\
          <td width=33% style='word-wrap:break-word' id=chars></td>\
         </tr>\
        </table>\
   </td></tr>"
   var table = document.createElement("table");
   table.className = 'fontSelect';
   var len = standardFonts.length;
   for (var i=0; i<len; i++) {
       var n = standardFonts[i];
       var cell = table.insertRow(-1).insertCell(-1);
       cell.style.fontFamily = n;
       cell.onclick = function(event) {
           captureFont(event.currentTarget.style.fontFamily);
       }
       cell.appendChild(document.createTextNode(n));
   }
   document.getElementById('localFont').appendChild(table);
   var button = document.createElement('input');
   button.type = 'button';
   button.value = "Font from URL...";
   button.onclick = loadRemoteFont;
   document.getElementById('remoteFont').appendChild(button);
}

var remoteFontUrl = '';
function loadRemoteFont() {
    remoteFontUrl = prompt("Enter font URL", remoteFontUrl);
}
function captureFont(font) {
    var glyph = document.getElementById('glyph');
    var view = null;
    var canvas = document.getElementById('capture');
    ch=34;
    var chars = document.getElementById("chars");
    chars.style.fontFamily = font;
    chars.textContent = '';
    function capture() {
        var model = captureGlyph(font, String.fromCharCode(ch), canvas);
        if (view) {
            glyph.removeChild(glyph.lastChild);
        }
        view = new GlyphView(model, 8 , {
            active:false,
            border: '1px solid #eeeeee'
        });
        glyph.appendChild(view.widget);
        chars.textContent=chars.textContent+String.fromCharCode(ch);
        if (chars.textContent.length % 20 == 0)
            chars.textContent+=' ';
        ch++;
    };
    capture();
    setInterval(capture, 2000);
}

function captureGlyph(font, ch, canvas)
{
    if (!canvas)
        canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = 200;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    var reqsize = Math.round(fontHeight*1.6)
    ctx.font = reqsize +"px "+font;
    var drawnHeight = parseInt(ctx.font.match(/(\d+)[^\d]+/)[1]);
    assert(drawnHeight);
    var baseline = drawnHeight+1; //the bottom line of the font
    ctx.fillText(ch, 2, drawnHeight);
    var data = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //scan right vertical border
    var l = scanLeftBorder(data);
    var r = scanRightBorder(data);
    var b = scanBottomBorder(data);
    var t = scanTopBorder(data);
    var actualWidth = r-l+1;
    var actualHeight = b-t+1;
    if (actualHeight < fontHeight) {
         if (t >= drawnHeight/2) { //shape is at bottom
             t = b-drawnHeight+1;
             if (t < 0)
                 t = 0;
             actualHeight = drawnHeight;
             console.warn("drawn shape is smaller than fontHeight, shape is at bottom half,\
                           setting capture area 0->fontHeight");
         } else {
             actualHeight = drawnHeight;
             console.warn("drawn shape is smaller than fontHeight, shape is at top half,\
                           setting capture area shapeTop->shapeTop+fontHeight");
         }
    }
    var ratio = actualHeight / fontHeight;
    data = ctx.getImageData(l,t,actualWidth,actualHeight);
    var width = data.width;
    var height = data.height;
    if (ratio > 1.00) {
        ctx.putImageData(data, 0, 0);
        while(ratio > 1.0) {
             console.log("iter("+ch+"): height=", height, " ratio=", ratio, "req fontsize:", reqsize, "actual:", drawnHeight);
            //select target height that is at most 2 times smaller
            var newHeight = (ratio >= 2.0)
                ? ((height+1)/2)|0 //round upward, so that the ratio is always <=2
                : fontHeight;
            var iterRatio = height / newHeight;
            assert(iterRatio <= 2.0);
            var newWidth = Math.round(width / iterRatio);
            ctx.drawImage(canvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
            width = newWidth;
            height = newHeight;
            ratio = height / fontHeight;
        }
        assert(ratio == 1.0);
        data = ctx.getImageData(0,0,width,height);
    }
    else // not (ratio > 1.0)
    {
        assert(ratio == 1.0);
        console.log("ratio is as expectedm height=", height);
    }
    var canv = document.createElement("canvas");
    canv.width = data.width;
    canv.height = data.height;
    canv.getContext("2d").putImageData(data, 0, 0);

    ctx.drawImage(canv, 0, 0, data.width, data.height, 0, 0, canvas.width, canvas.height);
    canvas.style.width=data.width*10;
    canvas.style.height=data.height*10;

    var model = new GlyphModel(width, fontHeight);
    model.loadFromImgData(data);
    return model;
}
function assert(cond) {
    if (!cond)
        throw new Error("assertion failed");
}
function putPixel(ctx, x, y, r,g,b,a) {
    var pixel = ctx.createImageData(1,1);
    var d = pixel.data;
    d[0] = r;
    d[1] = g;
    d[2] = b;
    d[3] = a;
    ctx.putImageData(pixel, x, y);
}

function scanRightBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x = w-1; x >= 0; x--)
        for (var y = 0; y<h; y++) {
            if (data[(y*w+x)<<2] < borderBlackThresh)
                return x;
        }
    return -1;
}

function scanLeftBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x=0; x<w; x++)
        for (var y=0; y<h; y++) {
            if (data[(y*w+x)<<2] < borderBlackThresh)
                return x;
        }
    return -1;
}

function scanTopBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y = 0; y<h; y++)
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < borderBlackThresh)
                return y;
        }
    return -1;
}

function scanBottomBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y=h-1; y>=0; y--) {
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < borderBlackThresh)
                return y;
        }
    }
    return -1;
}

/*
@font-face {
  font-family: "Kimberley";
  src: url(http://www.princexml.com/fonts/larabie/kimberle.ttf) format("truetype");
}

font-family: "Kimberley", sans-serif;
*/
window.onload = fontOpenGui(); //loadEditor();
</script>
</html>
