<html>
<head>
<style>
body {
    margin: 2px;
    height: 99%;
}
#main {
    height: 100%;
    margin: 0px;
}
.hide {
    visibility: hidden;
}
#loadGui {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
}
.glyph {
    display: inline-block;
    vertical-align: top;
}

#menu {
    border-bottom: 1px solid #eeeeee;
}
#editorGroup {
    border-right: 1px solid #eeeeee;
}
#editorGui {
   border-bottom: 1px solid #eeeeee;
   border-left: 1px solid #eeeeee;
}
#editor {
    display: inline-block;
    text-align: center;
    border: 1px solid #eeeeee;
}
#typingArea {
    border: 0px;
    border-bottom: 1px solid #eeeeee;
    background-color: #f0f0f0;
    height: 80px;
    width: 100%;
}
#lcd {
 height: 128px;
 width:256px;
 background: linear-gradient(to bottom, #f1f7de 0%,#cfd9b0 100%);
 overflow: hidden;
}

#glyphs {
    display: block;
    overflow-y: scroll;
    height: 100%;
}
#spacer {
    flex: 0 0 10px;
}
.glyph {
    flex: 0 0 auto;
    border: 1px solid #eeeeee;
    margin: 4px;
}
.openCaption {
    text-align: center;
    font-size: 44px;
    flex: 0 0 auto;
    padding-top: 15px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eeeeee;
}

.openBtnPanel {
    flex: 0 0 auto;
    display: flex;
    flex-flow: row;
}

.openModeSection {
    flex: 1 1 50%;
    flex-flow: column;
    justify-content: space-around;
}
.file-input {
    visibility:hidden;
    width: 100px;
}
.openBtn {
    flex: 0 0 auto;
    flex-flow: row;
    align-self: center;
    text-align: center;
    border-radius: 8px;
    border: 2px solid #eeeeee;
    padding: 10px;
    cursor: hand;
    font-size: 20px;
}
.openBtn:hover {
    background: lightblue;
}
.openOptions {
    flex: 0 0 auto;
    align-self: center;
    display: flex;
    flex-flow: column;
}
.fontSelect {
    flex: 0 0 auto;
    align-self: center;
}
.borderBottomRight {
   border-bottom: 1px solid #eeeeee;
   border-right: 1px solid #eeeeee;
}
.ctx-menu {
    position: absolute;
    display: block;
    opacity: 0;
    transform-origin: center;
    z-index: 2;
    opacity: 0;
    transform: scale(0);
    transition: transform 0.2s, opacity 0.2s;
    border: 1px solid #eeeeee;
    border-radius: 2px;
}
.ctx-menu.show {
  background-color: #ffffff;
  opacity: 1;
  transform: scale(1);
  transform-origin: top left;
}

.menu-item {
    display: block;
    list-style-type: none;
    padding: 10px 30px;
    transition: 0.1s;
    color: #666;
    font-size: 0.75em;
}
.menu-item:hover {
  background-color: #eee;
  cursor: pointer;
}
/*
.ctxMenu {
    position: absolute;
    z-index:1000;
    border: 1px solid black;
    padding: 2px;
    opacity: 1;
    background-color: white;
    cursor: hand;
    border-radius: 6px;
}
.ctxMenu tr:hover {
    background-color: lightblue
}
*/
</style>
</head>
<body>
  <div id=editorGui class="hide">
    <table id=main><tr>
        <td id=editorGroup>
            <table style=height:100%>
                <tr><td style="text-align: center">
                    <div id=editor></div>
                </td></tr>
                <tr><td>
                    <div style=text-align:center>LCD preview:</div>
                    <div id=lcd></div>
                    <textarea id=typingArea></textarea>
                </td></tr>
            </table>
        </td>
        <td>
            <div id= glyphs></div>
        </td>
    </tr></table>
  </div>
  <div id=loadGui>
      <div class=openCaption>Load font:</div>
      <table width=100%>
        <tr>
          <td style='width:33%'>
            <label class=openBtn>
                <span>C srcfile...</span>
                <input type=file class=file-input onchange='loadLocalFile(event, parseFontCSource);' />
            </label>
          </td>
          <td style='width:33%'>
            <label class=openBtn>
              <span>BDF file...</span>
              <input type=file class=file-input onchange='loadLocalFile(event, parseFontBdf);' />
            </label></td>
          <td style='width:33%'>
            <div class=openBtn onclick='fontSelectGui();'>Capture</div>
          </td>
        </tr>
        <tr>
            <td><div id=captureOptions class=openOptions></div></td>
        </tr>
  </table>
</body>

<script language=javascript>
const kColorFg = "black";
const kColorBg = "white";
var blackThresh = (localStorage.blackThresh === undefined)
    ? 170 : parseInt(localStorage.blackThresh);

var gConfig = {
    spaceWidth: 1,
    targetFontHeight: 10
}
var loadGui = document.getElementById("loadGui");
var editorGui = document.getElementById("editorGui");

function loadConfig() {
    for (var k in gConfig) {
        var strVal = localStorage[k];
        if (strVal !== undefined) {
            var val = parseInt(strVal);
            console.log("Config override from localStorage:", k, ":", gConfig[k], "->", val);
            gConfig[k] = val;
        }
    }
}
var gMonospaceFont = false;
function GlyphModel(w, h, ch)
{
    this.width = w;
    this.height = h;
    this.char = ch;
    this.allocate();
    this.listeners = new Array();
}
var gmProto = GlyphModel.prototype;
var UndoOp = Object.freeze({
    kSetPixel: 1,
    kDeleteCol: 2,
    kInsertCol: 3
});

gmProto.allocate = function()
{
    var h = this.height;
    var w = this.width;
    this.rows = new Array(h);
    for (var r=0; r<h; r++) {
        var row = this.rows[r] = new Array(w);
        for (var c=0; c<w; c++) {
           row[c] = false;
        }
    }
}
//accessor function to lazily create the undo buffer
gmProto.undoBuf = function() {
    var buf = this._undoBuf;
    if (!buf) {
        buf = this._undoBuf = [];
    }
    return buf;
}

gmProto.flip = function(x, y, isUndo)
{
    var row = this.rows[y];
    var curr = row[x];
    var val = row[x] = !curr;
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].onPixelChanged(x, y, val);
    }
    if (!isUndo) {
        this.undoBuf().push([UndoOp.kSetPixel, x, y, curr]);
    }
    return curr;
}

gmProto.set = function(x, y, val, isUndo)
{
    var row = this.rows[y];
    var oldVal = row[x];
    if (val === oldVal)
        return undefined;
    row[x] = val;
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].onPixelChanged(x, y, val);
    }
    if (!isUndo) {
        this.undoBuf().push([UndoOp.kSetPixel, x, y, oldVal]);
    }
    return oldVal;
}
gmProto.deleteColumn = function(x, isUndo)
{
    var oldCol = [];
    var h = this.height;
    for (var r = 0; r < h; r++) {
        var row = this.rows[r];
        oldCol.push(row[x]);
        row.splice(x, 1);
    }
    this.width--;
    if (!isUndo) {
        this.undoBuf().push([UndoOp.kInsertCol, x, oldCol]);
    }
    this.notifyDimensionsChanged();
}

gmProto.notifyDimensionsChanged = function()
{
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].onDimensionsChanged();
    }
}

gmProto.insertColumn = function(x, undoCol)
{
    var oldModel = this.clone();
    var h = this.height;
    if (x === this.width) {
        for (var r = 0; r < h; r++) {
            this.rows[r].push(undoCol ? undoCol[r] : false);
        }
    } else {
        for (var r = 0; r < h; r++) {
            this.rows[r].splice(x, 0, undoCol ? undoCol[r] : false);
        }
    }
    this.width++;
    if (!undoCol) {
        this.undoBuf().push([UndoOp.kDeleteCol, x]);
    }
    this.notifyDimensionsChanged();
}

gmProto.addListener = function(obj)
{
    this.listeners.push(obj);
}
gmProto.removeListener = function(obj) {
    var idx = this.listeners.indexOf(obj);
    if (idx < 0)
        return false;
    this.listeners.splice(idx, 1);
    return true;
}
gmProto.loadFromImgData = function(data) {
    var w = data.width;
    var h = data.height;
    if (w != this.width || h != this.height)
        throw new Error("Canvas has dimensions different than these of the model");
    data = data.data;
    for (var r = 0; r<h; r++) {
        var row = this.rows[r];
        for (var x = 0; x<w; x++) {
            row[x] = data[(r*w+x)*4] < blackThresh;
        }
    }
}
gmProto.clear = function() {
   this.allocate();
   var count = this.listeners.length;
   for (var i=0; i<count; i++) {
       this.listeners[i].onModelUpdated();
   }
}
gmProto.clone = function() {
    var result = new GlyphModel(this.width, this.height, this.char);
    var w = this.width;
    var h = this.height;
    var drows = result.rows;
    var rows = this.rows;
    for (var y = 0; y<h; y++) {
        var drow = drows[y];
        var row = rows[y];
        for (var x = 0; x<w; x++) {
            drow[x] = row[x];
        }
    }
    return result;
}
gmProto.migrateListeners = function(newModel)
{
//the listeners will detach from us when changeModel() is called,
//so we can't use a for loop
    var listeners = this.listeners;
    while (listeners.length) {
        listeners[0].changeModel(newModel);
    }
}

var gDragged = null;
var gCtxMenu = null;
class GlyphView {
    constructor(model, psize, opts) {
        this.model = model;
        this.psize = psize;
        this.opts = opts;
        this.fg = opts.fg || kColorFg;
        this.bg = opts.bg || kColorBg;
        this.widget = document.createElement('table');
        this.createGui();
        model.addListener(this);
        if (!opts.active) {
            this.updateToolTip();
        }
    }
    createGui() {
        var view = this.widget;
        this.setPixelSpacing(this.opts.pixSpacing);
        var rows = this.model.rows;
        var rowCnt = rows.length;
        var colCnt = rows[0].length;
        var palette = this.opts.palette ? this.opts.palette : null;
        for (var y = 0; y < rowCnt; y++) {
            var row = view.insertRow(-1);
            row.style.height = this.psize;
            var rowData = rows[y];
            for (var x = 0; x < colCnt; x++) {
                var cell = row.insertCell(-1);
                var cellData = rowData[x];
                var style = cell.style;
                style.width = this.psize;
                if (palette) {
                    style.backgroundColor = palette[cellData];
                } else {
                    style.backgroundColor = cellData ? this.fg : this.bg;
                }
                style.padding = 0;
                var border = this.opts.border;
                if (border === true) {
                    style.border = '1px solid #eeeeee';
                } else if (border) {
                    style.border = border;
                } else {
                    style.border = '0px';
                }
                cell.x = x;
                cell.y = y;
                if (this.opts.active) {
                    cell.onclick = (event) => {
                        var c = event.target;
                        var old = this.model.flip(c.x, c.y);
                    }
                    cell.ondragstart = function(event) {
                        // store a ref. on the dragged elem
                        gDragged = event.target;
                        // make it half transparent
                    };
                    cell.ondragover = (event) => {
                        if (!gDragged)
                        return;
                        var val = (gDragged.style.backgroundColor === this.bg) ? 0 : 1;
                        var target = event.target;
                        var old = this.model.set(target.x, target.y, val);
                    }

                    cell.oncontextmenu = (event) => {
                        this.ctxMenu(event);
                    }
                }
            }
        }
    }
    ctxMenu(event) {
        var self = this;
        var cell = event.currentTarget;
        var model = this.model;
        let m = CtxMenu.create(event);
        m.addItem("Clear glyph", "ctxClearGlyph", (event) => model.clear());
        if (!gMonospaceFont) {
            m.addItem("Delete column", "ctxDelCol", (event) => {
                if (model.width <= 1) {
                    return;
                }
                model.deleteColumn(cell.x);
            });
            m.addItem("Insert Column on Left", "ctxInsertColLeft", (event) => {
                model.insertColumn(cell.x);
            });
            m.addItem("Insert Column on Right", "ctxInsertColRight", (event) => {
                model.insertColumn(cell.x+1);
            });
        }
        m.show();
    }

    updateToolTip() {
        var model = this.model;
        this.widget.setAttribute('title',
        "Char: '" + String.fromCharCode(model.char) + "'\ncode: " + model.char +
        '\nwidth: '+model.width+"\nheight: "+model.height);
    }

    onPixelChanged(x,y,val) {
        var row = this.widget.rows[y];
        row.cells[x].style.backgroundColor = val ? this.fg : this.bg;
    }
    onDimensionsChanged() {
        this.widget.innerHTML = '';
        this.createGui();
        this.updateToolTip();
    }
    onModelUpdated() {
        this.widget.innerHTML = '';
        this.createGui();
    }
    changeModel(model) {
        if (model === this.model) {
            return;
        }
        this.model.removeListener(this);
        model.addListener(this);
        this.model = model;

        var h = this.widget.rows.length;
        var w = this.widget.rows[0].cells.length;
        if (h !== model.height || w !== model.width) {
            this.onDimensionsChanged();
        } else {
            this.onModelUpdated();
        }
    }

    setPixelSpacing(n) {
        if (n === undefined) {
            n = 0;
        }
        this.widget.style.borderSpacing = n+'px';
    }

    undo() {
        if (!this._undoBuf || this._undoBuf.length < 1) {
            console.log("No more undo history");
            return false;
        }
        var op = this._undoBuf.pop();
        switch(op[0]) {
            case UndoOp.kSetPixel: //pixel change
                this.set(op[1], op[2], op[3], true);
                break;
            case UndoOp.kDeleteCol:
                this.deleteColumn(op[1], true);
                break;
            case UndoOp.kInsertCol:
                this.insertColumn(op[1], op[2]);
                break;
            default:
                throw new Error("Unknown undo operation");
        }
        return true;
    }
}
var lcdLetters = [];
var gEditor = null;

function loadEditor(models) {
    loadGui.classList.add("hide");
    editorGui.classList.remove("hide");
    glyphCont = document.getElementById('glyphs');
    var glyphCount = models.length;
    var editorCont = document.getElementById('editor');

    for (var i = 0; i < glyphCount; i++) {
        var model = models[i];
        var view = new GlyphView(model, 4, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = view.widget;
        widget.model = model; //make the model accessible from the onclick handler
        widget.className = 'glyph';
        glyphCont.appendChild(view.widget);
        view.widget.onclick = function(event) {
            gEditor.changeModel(event.currentTarget.model);
        };
    }
    gEditor = new GlyphView(models[0], 10, {active: true});
    gEditor.widget.setAttribute('id', 'glyphEditor');
    document.addEventListener("keydown", function(event) {
        if (event.keyCode == 90 && event.ctrlKey) {
            gEditor.model.undo();
        }
    });
    editorCont.appendChild(gEditor.widget);
    var txtInput = document.getElementById('typingArea');
    txtInput.onkeypress = function(event) {
        var idx = event.charCode - 32;
        if (idx < 0 || idx >= glyphs.length)
            return;
        var bitmap = models[idx];
        var letter = new GlyphView(bitmap, 2, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = letter.widget;
        var style = widget.style;
        style.display = "inline-block";
        style.borderRight='2px solid transparent';
        lcd.appendChild(letter.widget);
   }
   txtInput.onkeydown = function(event) {
       if (event.keyCode === 8) { //backspace
           var child = lcd.lastChild;
           if (child)
               lcd.removeChild(child);
           return;
       }
   }
}
class CtxMenu {
    static instance = null;
    static create(event, html) {
        if (CtxMenu.instance) {
            CtxMenu.instance.destroy();
        }
        CtxMenu.instance = new CtxMenu(event, html);
        return CtxMenu.instance;
    }
    static show() {
        if (!CtxMenu.instance) {
            console.warn("CtxMenu.show: No context menu instance");
            return;
        }
        CtxMenu.instance.show();
    }
    static destroy() {
        if (!CtxMenu.instance) {
            return;
        }
        CtxMenu.instance.destroy();
        CtxMenu.instance = null;
    }
    constructor(event) {
        event.preventDefault();
        let w = this.widget = document.createElement("dl");
        w.classList.add("ctx-menu");
        w.style.top = event.pageY + "px";
        w.style.left = event.pageX + "px";
    }
    addItem(label, id, handler) {
        let w = this.widget;
        let li = document.createElement("li");
        li.classList.add("menu-item");
        li.setAttribute("id", id);
        li.addEventListener("click", handler);
        li.innerHTML = label;
        this.widget.appendChild(li);
    }
    show() {
        document.body.appendChild(this.widget);
        var clickHandler = function(event) {
            document.removeEventListener("click", clickHandler);
            if (event.currentTarget === this.widget) {
                alert("menu clicked");
            }
            CtxMenu.destroy();
        };
        document.addEventListener("click", clickHandler);
        setTimeout(()=>this.widget.classList.add("show"), 0); // unfold effect
    }
    destroy() {
        document.body.removeChild(this.widget);
    }
}
var standardFonts = ['arial', 'serif', 'sans-serif', 'monospace', 'Monaco, Lucida Console, monospace'];
/*
//Sans serif
'Arial, 'Arial Black', 'Tahoma', 'Trebuchet MS',
'Century Gothic', 'Geneva', 'Lucida','Lucida Sans', 'Lucida Grande',
//Serif
'Georgia', 'Times', 'Times New Roman',
'MS Serif', 'New York', 'Palatino', 'Palatino Linotype', 'Verdana',
//monospace
'Courier', 'Courier New', 'Lucida Console', 'Monaco'
*/

function fontSelectGui() {
   var cont = document.getElementById('captureOptions');
   while (cont.firstChild)
       cont.removeChild(cont.firstChild);
   cont.innerHTML =
   "<table width=100% style='table-layout:fixed'>\
   <tr>\
       <td id=localFont width=50% class=borderBottomRight></td>\
       <td id=remoteFont width=50% class=borderBottomRight></td></tr>\
   <tr><td colspan=2>\
        <table width=100%>\
         <tr>\
          <td><canvas id=capture style='border: 1px solid #0000ff;\
           width:200; height: 200; align-senf: center' /></td>\
           <td id=glyph></td>\
          <td width=33% style='word-wrap:break-word' id=chars></td>\
         </tr>\
        </table>\
   </td></tr>"
   var table = document.createElement("table");
   table.className = 'fontSelect';
   var len = standardFonts.length;
   for (var i=0; i<len; i++) {
       var n = standardFonts[i];
       var cell = table.insertRow(-1).insertCell(-1);
       cell.style.fontFamily = n;
       cell.onclick = function(event) {
           captureFont(event.currentTarget.style.fontFamily);
       }
       cell.appendChild(document.createTextNode(n));
   }
   document.getElementById('localFont').appendChild(table);
   var button = document.createElement('input');
   button.type = 'button';
   button.value = "Font from URL...";
   button.onclick = loadRemoteFont;
   document.getElementById('remoteFont').appendChild(button);
}

var remoteFontUrl = '';
function loadRemoteFont() {
    remoteFontUrl = prompt("Enter font URL", remoteFontUrl);
    captureFont(remoteFontUrl);
}

function loadLocalFile(event, parseFunc)
{
  var file = event.target.files[0];
  if (!file) {
    return;
  }
  var reader = new FileReader();
  reader.onload = function(e) {
    let models = parseFunc(e.target.result);
    if (typeof models === "string") {
        alert("Error parsing file: " + models);
        return;
    }
    loadEditor(models);
  };
  reader.readAsText(file);
}

function parseFontBdf(contents) {
    let parser = new BdfFontParser;
    return parser.parse(contents);
}

function parseFontCSource(contents)
{
    var m = contents.match(/Font\s+?[^\s]+?\(\d+\s*?,\s*?(\d+)\s*,/m);
    var fontHeight;
    if (m && m.length === 2) {
        fontHeight = parseInt(m[1]);
    };
    while(isNaN(fontHeight)) {
        hstr = prompt("Can't detect font height, please enter it");
        if (!hstr) {
            return;
        }
        fontHeight = parseInt(hstr);
    };
    //var bytesPerCol = ((fontHeight+7)/8)|0;
    var models = [];
    var lines = contents.match(/(0x[0-9a-fA-F]+[,\s]*){4,}/gm);
    var ll = lines.length;
    for (var l=0; l<ll; l++) {
        var line = lines[l];
        var bytes = line.match(/(0x[0-9a-fA-F]+)/g);
        models.push(loadModelFromSourceLine(line, width, fontHeight));
    }
    return models;
}

function loadModelFromSourceLineHScan(line, lineNo, bytes, fontHeight) {
    var width = bytes.length;
    var model = new GlyphModel(width, fontHeight, lineNo + 32);

    for (var col = 0; col < width; col++) {
        var byte = parseInt(bytes[col]);
        for (var i = 0; i < fontHeight; i++, byte >>= 1) {
            var row = model.rows[i];
            row[col] = (byte & 1) ? true : false;
        }
    }
}
//var canvas = document.getElementById('capture');
//var glyph = document.getElementById('glyph');
function captureFont(font)
{
    var cap = new FontCapturer(font, gConfig.targetFontHeight,
        document.getElementById('capture'));
    var models = cap.capture();
    loadEditor(models);
}

function FontCapturer(font, height, canvas)
{
    this.font = font;
    this.targetFontHeight = height;
    this.canvas = canvas;
    canvas.width = 200;
    canvas.height = 200;
    var ctx = this.ctx = canvas.getContext("2d");
    ctx.font = height +"px "+font;
    this.drawnFontSize = parseInt(ctx.font.match(/(\d+)[^\d]+/)[1]);
    assert(this.drawnFontSize);
}

var capProto = FontCapturer.prototype;

capProto.capture = function()
{
    this.detectFontTop();
    this.detectFontBottom();
    this.drawFontHeight = this.fontBottom-this.fontTop+1;
    this.ratio = this.drawFontHeight / this.targetFontHeight;
    if (this.ratio > 1.0) {
        console.log("Draw font height is not the same as the target one, capturer will scale the image", this.ratio, "times");
    }
    var models = [];
    for (var ch=32; ch < 127; ch++) {
        models.push(this.captureGlyph(String.fromCharCode(ch)));
    };
    return models;
}

capProto.clearCanvas = function() {
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = 'black';
}

capProto.drawGlyph = function(ch)
{
    this.clearCanvas();
    var baseline = this.drawnFontSize*2; //make sure we have enought space above the baseline
    this.ctx.fillText(ch, 2, baseline);
    return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
}

var bottomChars = ["g", "j", "p", "q", "y"];
//don't include '|', as it may be the only char that high - we want to use as many rows as possible
var topChars = ["h", "d", "t", "l", "]", "/", "^", "!", "O", "A", "8", "#", "%"];
var medChars = ["x", "v", "w", "z"];

capProto.detectFontBottom = function()
{
    var bottom = 0;
    var len = bottomChars.length;
    for (var i=0; i<len; i++) {
        var data = this.drawGlyph(bottomChars[i]);
        var b = scanBottomBorder(data);
        if (b > bottom) {
            bottom = b;
        }
        console.log('letter', bottomChars[i], 'bottom:', b);
    }
    this.fontBottom = bottom;
}

capProto.detectFontTop = function()
{
    var top = 0xffff;
    var len = topChars.length;
    for (var i=0; i<len; i++) {
        var data = this.drawGlyph(topChars[i]);
        var t = scanTopBorder(data);
        if (t < top) {
            top = t;
        }
    }
    this.fontTop = top;
}

capProto.captureGlyph = function(code)
{
    assert(this.fontBottom);
    assert(this.fontTop !== undefined);
    let ch = String.fromCharCode(code);
    var data = this.drawGlyph(ch);
    //scan width
    var l = scanLeftBorder(data);
    var r = scanRightBorder(data);
    if (l < 0) { //space
        assert(r < 0);
        l = 0;
        r = gConfig.spaceWidth-1;
    }
    var actualWidth = r-l+1;
    data = this.ctx.getImageData(l, this.fontTop, actualWidth, this.drawFontHeight);
    var width = data.width;
    var height = data.height;
    assert(height === this.drawFontHeight);
    var ratio = this.ratio;
    if (ratio > 1.00) {
        this.ctx.putImageData(data, 0, 0);
        while(ratio > 1.0) {
            console.log("iter("+ch+"): height=", height, " ratio=", ratio, "req fontsize:", this.targetFontHeight, "actual:", this.drawFontHeight);
            //select target height that is at most 2 times smaller
            var newHeight = (ratio >= 2.0)
                ? ((height+1)/2)|0 //round upward, so that the ratio is always <=2
                : this.targetFontHeight;
            var iterRatio = height / newHeight;
            assert(iterRatio <= 2.0);
            var newWidth = Math.round(width / iterRatio);
            this.ctx.drawImage(this.canvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
            width = newWidth;
            height = newHeight;
            ratio = height / this.targetFontHeight;
        }
        assert(ratio == 1.0);
        data = this.ctx.getImageData(0, 0, width, height);
    }
    else // not (ratio > 1.0)
    {
        assert(ratio == 1.0);
        console.log("ratio is as expected, height=", height);
    }
    var canv = document.createElement("canvas");
    canv.width = data.width;
    canv.height = data.height;
    canv.getContext("2d").putImageData(data, 0, 0);

    this.ctx.drawImage(this.canvas, 0, 0, data.width, data.height, 0, 0,
        this.canvas.width, this.canvas.height);

    var model = new GlyphModel(data.width, data.height, ch);
    model.loadFromImgData(data);
    return model;
}

function assert(cond) {
    if (!cond)
        throw new Error("assertion failed");
}

function scanRightBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x = w-1; x >= 0; x--)
        for (var y = 0; y<h; y++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return x;
        }
    return -1;
}

function scanLeftBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x=0; x<w; x++)
        for (var y=0; y<h; y++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return x;
        }
    return -1;
}

function scanTopBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y = 0; y<h; y++)
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return y;
        }
    return -1;
}

function scanBottomBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y=h-1; y>=0; y--) {
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return y;
        }
    }
    return -1;
}
class BdfFontParser {
    constructor() {
    }
    parse(contents) {
        let lines = this.lines = contents.split(/[\r\n]/gm);
        let lineCnt = lines.length;
        let models = this.models = [];
        let idx = 0;
        while (idx < lineCnt) {
            let m = lines[idx++].match(/FONTBOUNDINGBOX (\d+) (\d+) ([-\d]+) ([-\d]+)/);
            if (m) {
                this.fontW = parseInt(m[1]);
                this.fontH = parseInt(m[2]);
                this.yNormal = this.fontH + parseInt(m[4]);
                idx++;
                break;
            }
        }
        if (this.fontW == null) {
            return "No FONTBOUNDINGBOX line found";
        }
        while (idx < lineCnt) {
            for(;;) {
                if (lines[idx].match(/STARTCHAR/)) {
                    break;
                }
                idx++;
                if (idx >= lineCnt) {
                    return models;
                }
            }
            let ret = this.parseGlyph(idx);
            if (typeof ret === "string") { // error message
                return ret;
            }
            idx = ret[1];
            let model = ret[0];
            if (!model) { // we are not interested in this char
                continue;
            }
            models.push(model);
        }
        return models;
    }
    parseGlyph(idx) {
        var code;
        var xoffs, yoffs;
        let lines = this.lines;
        for (; idx < lines.length; idx++) {
            let line = lines[idx];
            let m = line.match(/([A-Z]+)[\s]*(.*)/);
            if (!m) {
                return "Cant tokenize line " + line;
            }
            let kw = m[1];
            if (kw === "ENCODING") {
                code = parseInt(m[2]);
                if (code < 32 || code > 255) {
                    return [null, idx+1];
                }
            } else if (kw === "BITMAP") {
                idx++;
                break;
            } else if (kw === "BBX") {
                let values = m[2].split(" ");
                xoffs = parseInt(values[2]);
                let h = parseInt(values[1]);
                yoffs = (this.yNormal - parseInt(values[3])) - h;
            } else if (kw === "ENDCHAR") {
                return "No BITMAP section";
            }
        }
        if (code == null) {
            return "No ENCODING section found";
        } else if (xoffs == null) {
            return "No BBX section found";
        }
        // parse hex values
        let model = new GlyphModel(this.fontW, this.fontH, code);
        while(idx < lines.length) {
            let line = lines[idx++];
            if (line.match(/ENDCHAR/)) {
                return [model, idx];
            }
            let row = model.rows[yoffs++];
            let x = xoffs;
            for (let hexOfs = 0; hexOfs < line.length; hexOfs += 8) { // process 32 bits at a time
                let hexChunk = line.substr(hexOfs, Math.min(line.length - hexOfs, 8));
                let mask = 1 << (hexChunk.length * 4 - 1);
                let bits = parseInt(hexChunk, 16);
                for (; mask; x++, mask >>>= 1) {
                    row[x] = (bits & mask) ? true : false;
                }
            }
        }
        return "Unexpected end of glyph";
    }
}
/*
@font-face {
  font-family: "Kimberley";
  src: url(http://www.princexml.com/fonts/larabie/kimberle.ttf) format("truetype");
}

font-family: "Kimberley", sans-serif;
*/
window.onload = function() {
    loadConfig();
}
</script>
</html>
