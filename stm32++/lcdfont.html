<html>
<head>
<style>
body {
    margin: 2px;
    height: 99%;
}
#main {
    height: 100%;
    margin: 0px;
}
.hide {
    visibility: hidden;
}
.disabled {
    opacity: 0.2;
    pointer-events: none;
}
#loadGui {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
}
.glyph {
    display: inline-block;
    vertical-align: top;
}

#menu {
    border-bottom: 1px solid #eeeeee;
}
#editorGui {
   border-bottom: 1px solid #eeeeee;
   border-left: 1px solid #eeeeee;
   height: 96%;
}
#editorGroup {
    border-right: 1px solid #eeeeee;
}
#glyphEditor {
    display: inline-block;
    text-align: center;
    border: 1px solid #eeeeee;
}
#typingArea {
    border: 0px;
    border-bottom: 1px solid #eeeeee;
    background-color: #f0f0f0;
    height: 80px;
    width: 100%;
}
#lcd {
 height: 128px;
 width:256px;
 background: linear-gradient(to bottom, #f1f7de 0%,#cfd9b0 100%);
 overflow: hidden;
}

#glyphs {
    display: block;
    overflow-y: scroll;
    height: 100%;
}
.glyph {
    flex: 0 0 auto;
    border: 1px solid #eeeeee;
    margin: 4px;
}
.fontSelect {
    flex: 0 0 auto;
    align-self: center;
}
.borderBottomRight {
   border-bottom: 1px solid #eeeeee;
   border-right: 1px solid #eeeeee;
}
.ctx-menu {
    position: absolute;
    display: block;
    opacity: 0;
    transform-origin: center;
    z-index: 2;
    opacity: 0;
    transform: scale(0);
    transition: transform 0.2s, opacity 0.2s;
    border: 1px solid #eeeeee;
    border-radius: 2px;
    margin: 0;
}
.ctx-menu.show {
  background-color: #ffffff;
  opacity: 1;
  transform: scale(1);
  transform-origin: top left;
}

.menu-item {
    display: block;
    list-style-type: none;
    padding: 10px 30px;
    transition: 0.1s;
    color: #666;
    font-size: 0.75em;
}
.menu-item:hover {
  background-color: #eee;
  cursor: pointer;
}
.dimmer {
    background: #000;
    opacity: 0.4;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
}
.progress-msg {
    position: fixed;
    top: 50%;
    left: 50%;
    color: green;
    z-index:101;
    transform: translate(-50%, -50%);
}
</style>
</head>
<body>
    <div id=menu>
        <label id=menuLoadBtn onclick='menuLoad(event)'><span>Load</span></label>
        <label id=menuOptionsBtn onclick='menuOptions(event)'><span>Options</span></label>
        <label id=menuSaveBtn class=disabled onclick='menuSave(event)'><span>Save</span><label>
        <div id=fontInfo></div>
    </div>
    <table id=editorGui class="hide"><tr>
        <td id=editorGroup>
            <table style=height:100%>
                <tr><td style="text-align: center">
                    <div id=glyphEditor></div>
                </td></tr>
                <tr><td>
                    <div style=text-align:center>LCD preview:</div>
                    <div id=lcd></div>
                    <textarea id=typingArea></textarea>
                </td></tr>
            </table>
        </td>
        <td>
            <div id=glyphs></div>
        </td>
    </tr></table>
    <div id=dimmer class=hide>
        <div class=progress-msg id=progress-msg></div>
    </div>
    </div>
</body>

<script language=javascript>
const kColorFg = "black";
const kColorBg = "white";
var blackThresh = (localStorage.blackThresh === undefined)
    ? 170 : parseInt(localStorage.blackThresh);

var gConfig = {
    spaceWidth: 1,
    targetFontHeight: 10
}
var loadGui = document.getElementById("loadGui");

function loadConfig() {
    for (var k in gConfig) {
        var strVal = localStorage[k];
        if (strVal !== undefined) {
            var val = parseInt(strVal);
            console.log("Config override from localStorage:", k, ":", gConfig[k], "->", val);
            gConfig[k] = val;
        }
    }
}

const UndoOp = Object.freeze({
    kSetPixel: 1,
    kDeleteCol: 2,
    kInsertCol: 3
});

class GlyphModel {
    constructor(w, h, charCode) {
        this.width = w;
        this.height = h;
        this.charCode = charCode;
        this.allocate();
        this.listeners = new Array();
    }
    get char() {
        return String.fromCharCode(this.charCode);
    }
    allocate() {
        var h = this.height;
        var w = this.width;
        this.rows = new Array(h);
        for (var r=0; r<h; r++) {
            var row = this.rows[r] = new Array(w);
            for (var c=0; c<w; c++) {
                row[c] = false;
            }
        }
    }
//accessor function to lazily create the undo buffer
    undoBuf() {
        var buf = this._undoBuf;
        if (!buf) {
            buf = this._undoBuf = [];
        }
        return buf;
    }

    flip(x, y, isUndo) {
        var row = this.rows[y];
        var curr = row[x];
        var val = row[x] = !curr;
        var count = this.listeners.length;
        for (var i=0; i<count; i++) {
            this.listeners[i].onPixelChanged(x, y, val);
        }
        if (!isUndo) {
            this.undoBuf().push([UndoOp.kSetPixel, x, y, curr]);
        }
        return curr;
    }
    undo() {
        if (!this._undoBuf || this._undoBuf.length < 1) {
            console.log("No more undo history");
            return false;
        }
        var op = this._undoBuf.pop();
        switch(op[0]) {
            case UndoOp.kSetPixel: //pixel change
                this.set(op[1], op[2], op[3], true);
                break;
            case UndoOp.kDeleteCol:
                this.deleteColumn(op[1], true);
                break;
            case UndoOp.kInsertCol:
                this.insertColumn(op[1], op[2]);
                break;
            default:
                throw new Error("Unknown undo operation");
        }
        return true;
    }
    set(x, y, val, isUndo) {
        var row = this.rows[y];
        var oldVal = row[x];
        if (val === oldVal)
        return undefined;
        row[x] = val;
        var count = this.listeners.length;
        for (var i=0; i<count; i++) {
            this.listeners[i].onPixelChanged(x, y, val);
        }
        if (!isUndo) {
            this.undoBuf().push([UndoOp.kSetPixel, x, y, oldVal]);
        }
        return oldVal;
    }
    deleteColumn(x, isUndo) {
        var oldCol = [];
        var h = this.height;
        for (var r = 0; r < h; r++) {
            var row = this.rows[r];
            oldCol.push(row[x]);
            row.splice(x, 1);
        }
        this.width--;
        if (!isUndo) {
            this.undoBuf().push([UndoOp.kInsertCol, x, oldCol]);
        }
        this.notifyDimensionsChanged();
    }
    trimHorizontal(trimAmount, left) {
        if (trimAmount >= this.width) {
            console.warn("trimHorizontal: Attempted to trim all width");
            return;
        }
        let h = this.height;
        let start, end;
        if (left) {
            start = trimAmount;
        } else {
            start = 0;
            end = -trimAmount;
        }
        for (var y = 0; y < h; y++) {
            this.rows[y] = this.rows[y].slice(start, end);
        }
        this.width -= trimAmount;
        this.notifyDimensionsChanged();
    }
    trimVertical(trimAmount, top) {
        if (trimAmount >= this.height) {
            console.warn("trimRight: Attempted to trim all height");
            return;
        }
        if (top) {
            this.rows = this.rows.slice(trimAmount);
        } else {
            this.rows = this.rows.slice(0, -trimAmount);
        }
        this.height -= trimAmount;
        this.notifyDimensionsChanged();
    }
    scale(xFactor, yFactor) {
        if (!yFactor) {
            yFactor = xFactor;
        }
        let h = this.height;
        let w = this.width;
        let newRows = [];
        for (var y = 0; y < h; y++) {
            let row = this.rows[y];
            let newRow = [];
            for (let x = 0; x < w; x++) {
                let pixel = row[x];
                for (let rpt = 0; rpt < xFactor; rpt++) {
                    newRow.push(pixel);
                }
            }
            newRows.push(newRow);
            for (let rpt = 1; rpt < yFactor; rpt++) {
                newRows.push([...newRow]);
            }
        }
        this.rows = newRows;
        this.width *= xFactor;
        this.height *= yFactor;
        this.notifyDimensionsChanged();
    }
    notifyDimensionsChanged() {
        var count = this.listeners.length;
        for (var i=0; i<count; i++) {
            this.listeners[i].onDimensionsChanged();
        }
    }
    insertColumn(x, undoCol) {
        var oldModel = this.clone();
        var h = this.height;
        if (x === this.width) {
            for (var r = 0; r < h; r++) {
                this.rows[r].push(undoCol ? undoCol[r] : false);
            }
        } else {
            for (var r = 0; r < h; r++) {
                this.rows[r].splice(x, 0, undoCol ? undoCol[r] : false);
            }
        }
        this.width++;
        if (!undoCol) {
            this.undoBuf().push([UndoOp.kDeleteCol, x]);
        }
        this.notifyDimensionsChanged();
    }
    addListener(obj) {
        this.listeners.push(obj);
    }
    removeListener(obj) {
        var idx = this.listeners.indexOf(obj);
        if (idx < 0)
        return false;
        this.listeners.splice(idx, 1);
        return true;
    }
    loadFromImgData(data) {
        var w = data.width;
        var h = data.height;
        if (w != this.width || h != this.height)
        throw new Error("Canvas has dimensions different than these of the model");
        data = data.data;
        for (var r = 0; r<h; r++) {
            var row = this.rows[r];
            for (var x = 0; x<w; x++) {
                row[x] = data[(r*w+x)*4] < blackThresh;
            }
        }
    }
    clear() {
        this.allocate();
        var count = this.listeners.length;
        for (var i=0; i<count; i++) {
            this.listeners[i].onModelUpdated();
        }
    }
    clone() {
        var result = new GlyphModel(this.width, this.height, this.charCode);
        var w = this.width;
        var h = this.height;
        var drows = result.rows;
        var rows = this.rows;
        for (var y = 0; y<h; y++) {
            var drow = drows[y];
            var row = rows[y];
            for (var x = 0; x<w; x++) {
                drow[x] = row[x];
            }
        }
        return result;
    }
    migrateListeners(newModel) {
//the listeners will detach from us when changeModel() is called,
//so we can't use a for loop
        var listeners = this.listeners;
        while (listeners.length) {
            listeners[0].changeModel(newModel);
        }
    }
    whitespaceRight() {
        let rows = this.rows;
        let w = this.width;
        let h = this.height;
        for (let col = w-1; col >= 0; col--) {
            for (let row = 0; row < h; row++) {
                if (rows[row][col]) {
                    return w - col - 1;
                }
            }
        }
        return w;
    }
    whitespaceLeft() {
        let rows = this.rows;
        let w = this.width;
        let h = this.height;
        for (let col = 0; col < w; col++) {
            for (let row = 0; row < h; row++) {
                if (rows[row][col]) {
                    return col;
                }
            }
        }
        return w;
    }
    whitespaceTop() {
        let rows = this.rows;
        let h = this.height;
        let w = this.width;
        for (let y = 0; y < h; y++) {
            let row = rows[y];
            for (let x = 0; x < w; x++) {
                if (row[x]) {
                    return y;
                }
            }
        }
        return h;
    }
    whitespaceBottom() {
        let rows = this.rows;
        let h = this.height;
        let w = this.width;
        for (let y = h - 1; y >= 0; y--) {
            let row = rows[y];
            for (let x = 0; x < w; x++) {
                if (row[x]) {
                    return h - y - 1;
                }
            }
        }
        return h;
    }

}
var gEditor = null;
var gDragged = null;
var gCtxMenu = null;
class GlyphView {
    constructor(model, psize, opts) {
        this.model = model;
        this.psize = psize;
        this.opts = opts;
        this.fg = opts.fg || kColorFg;
        this.bg = opts.bg || kColorBg;
        this.widget = document.createElement('table');
        this.createGui();
        model.addListener(this);
        if (!opts.active) {
            this.updateToolTip();
        }
    }
    createGui() {
        var view = this.widget;
        view.glyphView = this;
        this.setPixelSpacing(this.opts.pixSpacing);
        var rows = this.model.rows;
        var rowCnt = rows.length;
        var colCnt = rows[0].length;
        var palette = this.opts.palette ? this.opts.palette : null;
        for (var y = 0; y < rowCnt; y++) {
            var row = view.insertRow(-1);
            row.style.height = this.psize;
            var rowData = rows[y];
            for (var x = 0; x < colCnt; x++) {
                var cell = row.insertCell(-1);
                var cellData = rowData[x];
                var style = cell.style;
                style.width = this.psize;
                if (palette) {
                    style.backgroundColor = palette[cellData];
                } else {
                    style.backgroundColor = cellData ? this.fg : this.bg;
                }
                style.padding = 0;
                var border = this.opts.border;
                if (border === true) {
                    style.border = '1px solid #eeeeee';
                } else if (border) {
                    style.border = border;
                } else {
                    style.border = '0px';
                }
                cell.x = x;
                cell.y = y;
                if (this.opts.active) {
                    cell.onclick = (event) => {
                        var c = event.target;
                        var old = this.model.flip(c.x, c.y);
                    }
                    cell.ondragstart = function(event) {
                        console.log("dragstart");
                        // store a ref. on the dragged elem
                        gDragged = event.target;
                        // make it half transparent
                    };
                    cell.ondragover = (event) => {
                        console.log("dragover");
                        if (!gDragged)
                        return;
                        var val = (gDragged.style.backgroundColor === this.bg) ? 0 : 1;
                        var target = event.target;
                        var old = this.model.set(target.x, target.y, val);
                    }

                    cell.oncontextmenu = (event) => {
                        this.ctxMenu(event);
                    }
                }
            }
        }
    }
    ctxMenu(event) {
        var self = this;
        var cell = event.currentTarget;
        var model = this.model;
        event.preventDefault();
        let m = CtxMenu.create();
        m.addItem("Clear glyph", "ctxClearGlyph", (event) => model.clear());
        if (!gEditor.monoWidth) {
            m.addItem("Delete column", "ctxDelCol", (event) => {
                if (model.width <= 1) {
                    return;
                }
                model.deleteColumn(cell.x);
            });
            m.addItem("Insert Column on Left", "ctxInsertColLeft", (event) => {
                model.insertColumn(cell.x);
            });
            m.addItem("Insert Column on Right", "ctxInsertColRight", (event) => {
                model.insertColumn(cell.x+1);
            });
        }
        m.show(event.pageX, event.pageY);
    }

    updateToolTip() {
        var model = this.model;
        this.widget.setAttribute('title',
        "Char: '" + model.char + "'\ncode: " + model.charCode +
        '\nwidth: '+model.width+"\nheight: "+model.height);
    }

    onPixelChanged(x,y,val) {
        var row = this.widget.rows[y];
        row.cells[x].style.backgroundColor = val ? this.fg : this.bg;
    }
    onDimensionsChanged() {
        this.widget.innerHTML = '';
        this.createGui();
        this.updateToolTip();
    }
    onModelUpdated() {
        this.widget.innerHTML = '';
        this.createGui();
    }
    changeModel(model) {
        if (model === this.model) {
            return;
        }
        this.model.removeListener(this);
        model.addListener(this);
        this.model = model;

        var h = this.widget.rows.length;
        var w = this.widget.rows[0].cells.length;
        if (h !== model.height || w !== model.width) {
            this.onDimensionsChanged();
        } else {
            this.onModelUpdated();
        }
    }

    setPixelSpacing(n) {
        if (n === undefined) {
            n = 0;
        }
        this.widget.style.borderSpacing = n+'px';
    }

}
var lcdLetters = [];

class FontEditor {
constructor() {
    this.widget = document.getElementById("editorGui");
    this.glyphListWidget = document.getElementById("glyphs");
    this.editorWidget = document.getElementById("glyphEditor");
    this.progressMsgWidget = document.getElementById("progress-msg");
    this.glyphListRclickHandler = this.onGlyphRightClick.bind(this);
}
load(models, name) {
    let tsStart = Date.now();
    this.models = models;
    this.preprocess();
    this.glyphListWidget.innerHTML = this.editorWidget.innerHTML = "";
    this.widget.classList.remove("hide");
    var glyphCount = models.length;
    for (var i = 0; i < glyphCount; i++) {
        var model = models[i];
        let view = this.createGlyphViewForList(model);
        this.glyphListWidget.appendChild(view.widget);
    }
    this.fontName = name;
    let editor = this.glyphEditor = new GlyphView(models[1], 10, {active: true});
    editor.widget.setAttribute('id', 'glyphEditor');
    document.addEventListener("keydown", function(event) {
        if (event.keyCode == 90 && event.ctrlKey) {
            editor.model.undo();
        }
    });
    this.editorWidget.appendChild(editor.widget);
    var txtInput = document.getElementById('typingArea');
    txtInput.onkeypress = function(event) {
        var idx = event.charCode - 32;
        if (idx < 0 || idx >= glyphs.length)
            return;
        var bitmap = models[idx];
        var letter = new GlyphView(bitmap, 2, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = letter.widget;
        var style = widget.style;
        style.display = "inline-block";
        style.borderRight='2px solid transparent';
        lcd.appendChild(letter.widget);
   }
   txtInput.onkeydown = function(event) {
       if (event.keyCode === 8) { //backspace
           var child = lcd.lastChild;
           if (child)
               lcd.removeChild(child);
           return;
       }
   }
   document.getElementById("menuSaveBtn").classList.remove("disabled");
   console.log(`GUI editor load took ${Date.now() - tsStart} ms`);
}
createGlyphViewForList(model) {
    var view = new GlyphView(model, 4, {active: false, bg: 'rgba(255,255,255,0)'});
    var widget = view.widget;
    widget.className = 'glyph';
    view.widget.onclick = (event) => {
        this.glyphEditor.changeModel(event.currentTarget.glyphView.model);
    };
    view.widget.oncontextmenu = this.glyphListRclickHandler;

    return view;
}
warnAsciiOrder() {
    if (this._asciiOrderWarningConfirmed) {
        return true;
    }
    return this._asciiOrderWarningConfirmed = window.confirm(
        "Inserting or deleting a glyph will change the code->glyph mapping (ok for pictogram fonts). Are you sure?"
    );
}
onGlyphRightClick(event) {
    event.preventDefault();
    let view = event.currentTarget.glyphView;
    let m = CtxMenu.create();
    m.addItem("Delete", null, (event) => {
        if (this.warnAsciiOrder()) {
            this.deleteGlyph(view);
        }
    });
    m.addItem("Insert", null, (event) => {
        if (this.warnAsciiOrder()) {
            this.insertGlyphBefore(view);
        }
    });
    m.show(event.pageX, event.pageY);
}
indexOfGlyphView(glyphView) {
    let model = glyphView.model;
    let models = this.models;
    for (let idx = 0; idx < models.length; idx++) {
        let m = models[idx];
        if (m === model) {
            return idx;
        }
    }
    console.warn("Index of glyph not found");
    return -1;
}
deleteGlyph(glyphView) {
    let idx = this.indexOfGlyphView(glyphView);
    if (idx < 0) {
        return;
    }
    let models = this.models;
    if (this.glyphEditor.model === glyphView.model) {
        if (idx < models.length - 1) {
            this.glyphEditor.changeModel(models[idx+1]);
        } else if (idx > 0) {
            this.glyphEditor.changeModel(models[idx-1]);
        } else {
            assert(models.length === 1);
            this.glyphEditor.clearModel();
        }
    }
    models.splice(idx, 1);
    this.glyphListWidget.removeChild(glyphView.widget);
}
insertGlyphBefore(glyphView) {
    let idx = this.indexOfGlyphView(glyphView);
    if (idx < 0) {
        return;
    }
    let char;
    do {
        char = prompt("Enter char code:");
    } while(!char || char.length !== 1);
    let model = new GlyphModel(this.monoWidth, this.fontHeight, char.charCodeAt(0));
    this.models.splice(idx, 0, model);
    let newView = this.createGlyphViewForList(model);
    this.glyphListWidget.insertBefore(newView.widget, glyphView.widget);
    this.glyphEditor.changeModel(model);
}
preprocess() {
    let model0 = this.models[0];
    let width0 = model0.width;
    let height0 = model0.height;
    let minLeft = 100000;
    let minRight = 100000;
    let minTop = 100000;
    let minBottom = 100000;
    for (let model of this.models) {
        if (model.width !== width0) {
            console.warn("preprocess: Font is not monospace");
            return this.standaloneCheckFontHeight();
        }
        if (model.height !== height0) {
            throw new Error("preprocess: Glyph height is not equal");
        }
        let wsLeft = model.whitespaceLeft();
        if (wsLeft < minLeft) {
            minLeft = wsLeft;
        }
        let wsRight = model.whitespaceRight();
        if (wsRight < minRight) {
            minRight = wsRight;
        }
        let wsTop = model.whitespaceTop();
        if (wsTop < minTop) {
            minTop = wsTop;
        }
        let wsBottom = model.whitespaceBottom();
        if (wsBottom < minBottom) {
            minBottom = wsBottom;
        }
    }
    for (let model of this.models) {
        if (minLeft) {
            model.trimHorizontal(minLeft, true);
        }
        if (minRight) {
            model.trimHorizontal(minRight);
        }
        if (minTop) {
            model.trimVertical(minTop, true);
        }
        if (minBottom) {
            model.trimVertical(minBottom);
        }
    }
    this.monoWidth = model0.width;
    this.fontHeight = model0.height;
    if (minLeft) {
        console.warn(`Trimmed left by ${minLeft} pixels`);
    }
    if (minRight) {
        console.warn(`Trimmed right by ${minRight} pixels`);
    }
    if (minTop) {
        console.warn(`Trimmed top by ${minTop} pixels`);
    }
    if (minBottom) {
        console.warn(`Trimmed bottom by ${minBottom} pixels`);
    }
}
standaloneCheckFontHeight() {
    let height0 = this.models[0].height;
    for (let model of this.models) {
        if (model.height !== height0) {
            throw new Error("Glyphs are not the same height");
        }
    }
    this.fontHeight = height0;
}

scale(xFactor, yFactor) {
    assert(xFactor);
    for (let model of this.models) {
        model.scale(xFactor, yFactor);
    }
    if (this.monoWidth) {
        this.monoWidth *= xFactor;
    }
}
readLocalFile() {
    return new Promise((resolve, reject) => {
        let fi = document.createElement("input");
        fi.setAttribute("type", "file");
        fi.onchange = (event) => {
            var file = event.target.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function(e) {
                resolve([e.target.result, file.name.replace(/\.[a-zA-Z]+$/, '')]);
            }
            reader.readAsText(file);
        }
        fi.click();
    });
}
showSpinner(msg) {
    let dimmer = document.getElementById("dimmer");
    dimmer.className = "dimmer";
    if (msg) {
        this.progressMsgWidget.innerHTML = msg;
    }
}
hideSpinner() {
    let dimmer = document.getElementById("dimmer");
    dimmer.className = "hide";
}

async importFromBdfFile() {
    this.showSpinner("Parsing file....");
    let data = await this.readLocalFile();
    let parser = new BdfFontParser;
    try {
        let tsStart = Date.now();
        let models = parser.parse(data[0]);
        console.log(`BDF file parse took ${Date.now()-tsStart} ms`);
        this.load(models, data[1]);
    } catch(e) {
        alert(e);
    }
    this.hideSpinner();
}

async importFromCSource() {
    this.showSpinner("Parsing file....");
    try {
        let data = await this.readLocalFile();
        let contents = data[0];
        var m = contents.match(/extern Font const\s+[^\s]+\([^,]+,\s*\d+,\s*(\d+).+/);
        if (m && m.length === 2) {
            this.fontHeight = parseInt(m[1]);
        };
        while(isNaN(this.fontHeight)) {
            hstr = prompt("Can't detect font height, please enter it");
            if (!hstr) {
                return;
            }
            this.fontHeight = parseInt(hstr);
        };
        var bytesPerCol = Math.floor((this.fontHeight + 7) / 8);
        var models = [];
        var lines = contents.match(/(0x[0-9a-fA-F]+[,\s]*){4,}/gm);
        var ll = lines.length;
        for (var l=0; l<ll; l++) {
            var bytes = lines[l].match(/(0x[0-9a-fA-F]+)/g);
            if (bytes.length % bytesPerCol) {
                throw new Error(`Incorrect number of bytes at row ${l}`);
            }
            let model = new GlyphModel(Math.round(bytes.length / bytesPerCol), this.fontHeight, l + 32);
            let rows = model.rows;
            for (let byteIdx = 0; byteIdx < bytes.length; byteIdx++) {
                let byte = parseInt(bytes[byteIdx]);
                let col = Math.floor(byteIdx / bytesPerCol);
                for (let bit = 0; bit < 8; bit++) {
                    let mask = 1 << bit;
                    if (byte & mask) {
                        let row = (byteIdx % bytesPerCol) * 8 + bit;
                        if (row < rows.length) {
                            rows[row][col] = true;
                        }
                    }
                }
            }
            models.push(model);
        }
        this.load(models, data[1]);
    } finally {
        this.hideSpinner();
    }
}

exportToCSource(name) {
    if (name) {
        this.fontName = name;
    }
    if (!this.fontName) {
        throw new Error("Font name not set");
    }
    let text =
`/* Vertical-scan bitmap data for font ${this.fontName}
 * Defines ASCII characters from ${this.models[0].charCode} to ${this.models[this.models.length-1].charCode}
 * Generated with lcdfont utility by Alexander Vassilev
 */
#include <font.hpp>
static const unsigned char _font_${this.fontName}_data[] = {\n`;
    let models = this.models;
    let lastModel = models[models.length -1];
    for (let model of models) {
        let rows = model.rows;
        text += "    ";
        for (let x = 0; x < model.width; x++) {
            let byte = 0;
            let mask = 0x01;
            for (let y = 0; y < model.height; y++) {
                if (rows[y][x]) {
                    byte |= mask;
                }
                mask <<= 1;
                if (mask > 0x80) {
                    text += `0x${byte < 16 ? 0 : ''}${byte.toString(16)},`;
                    mask = 0x01;
                    byte = 0;
                }
            }
            if (mask > 0x01) {
                text += `0x${byte < 16 ? 0 : ''}${byte.toString(16)},`;
            }
        }
        if (model === lastModel) {
            text = text.slice(0, -1) + ' ';
        }
        text += ` // ${model.char !== '\\' ? model.char : 'backslash'} (${model.charCode})\n`;
    }
    text +=
`};\n
// (isVertical, width, height, count, charSpacing, lineSpacing, data, widths)
extern Font const font_${this.fontName}(true, ${this.monoWidth}, ${this.fontHeight}, ${models.length}, 1, 1, _font_${this.fontName}_data, nullptr);`;
    return text;
}
}
class CtxMenu {
    static instance = null;
    static create(x, y) {
        if (CtxMenu.instance) {
            CtxMenu.instance.destroy();
        }
        CtxMenu.instance = new CtxMenu(x, y);
        return CtxMenu.instance;
    }
    static destroy() {
        if (!CtxMenu.instance) {
            return;
        }
        CtxMenu.instance.destroy();
        CtxMenu.instance = null;
    }
    constructor() {
        let w = this.widget = document.createElement("dl");
        w.classList.add("ctx-menu");
    }
    addItem(label, id, handler) {
        let w = this.widget;
        let li = document.createElement("li");
        li.classList.add("menu-item");
        if (id) {
            li.setAttribute("id", id);
        }
        if (handler) {
            li.addEventListener("click", handler);
        }
        li.innerHTML = label;
        this.widget.appendChild(li);
    }
    addRawItem(html) {
        let w = this.widget;
        let li = document.createElement("li");
        li.classList.add("menu-item");
        li.innerHTML = html;
        this.widget.appendChild(li);
    }
    show(x, y) {
        let w = this.widget;
        w.style.left = x + "px";
        w.style.top = y + "px";
        document.body.appendChild(w);
        var clickHandler = function(event) {
            document.removeEventListener("click", clickHandler);
            if (event.currentTarget === w) {
                alert("menu clicked");
            }
            CtxMenu.destroy();
        };
        document.addEventListener("click", clickHandler);
        setTimeout(()=>w.classList.add("show"), 0); // unfold effect
    }
    destroy() {
        document.body.removeChild(this.widget);
    }
}
var standardFonts = ['arial', 'serif', 'sans-serif', 'monospace', 'Monaco, Lucida Console, monospace'];
/*
//Sans serif
'Arial, 'Arial Black', 'Tahoma', 'Trebuchet MS',
'Century Gothic', 'Geneva', 'Lucida','Lucida Sans', 'Lucida Grande',
//Serif
'Georgia', 'Times', 'Times New Roman',
'MS Serif', 'New York', 'Palatino', 'Palatino Linotype', 'Verdana',
//monospace
'Courier', 'Courier New', 'Lucida Console', 'Monaco'
*/

function fontSelectGui() {
   var cont = document.getElementById('captureOptions');
   cont.innerHTML =
   "<table width=100% style='table-layout:fixed'>\
   <tr>\
       <td id=localFont width=50% class=borderBottomRight></td>\
       <td id=remoteFont width=50% class=borderBottomRight></td></tr>\
   <tr><td colspan=2>\
        <table width=100%>\
         <tr>\
          <td><canvas id=capture style='border: 1px solid #0000ff;\
           width:200; height: 200; align-senf: center' /></td>\
           <td id=glyph></td>\
          <td width=33% style='word-wrap:break-word' id=chars></td>\
         </tr>\
        </table>\
   </td></tr>"
   var table = document.createElement("table");
   table.className = 'fontSelect';
   var len = standardFonts.length;
   for (var i=0; i<len; i++) {
       var n = standardFonts[i];
       var cell = table.insertRow(-1).insertCell(-1);
       cell.style.fontFamily = n;
       cell.onclick = function(event) {
           captureFont(event.currentTarget.style.fontFamily);
       }
       cell.appendChild(document.createTextNode(n));
   }
   document.getElementById('localFont').appendChild(table);
   var button = document.createElement('input');
   button.type = 'button';
   button.value = "Font from URL...";
   button.onclick = loadRemoteFont;
   document.getElementById('remoteFont').appendChild(button);
}

var remoteFontUrl = '';
function loadRemoteFont() {
    remoteFontUrl = prompt("Enter font URL", remoteFontUrl);
    captureFont(remoteFontUrl);
}
function loadModelFromSourceLineHScan(line, lineNo, bytes, fontHeight) {
    var width = bytes.length;
    var model = new GlyphModel(width, fontHeight, lineNo + 32);

    for (var col = 0; col < width; col++) {
        var byte = parseInt(bytes[col]);
        for (var i = 0; i < fontHeight; i++, byte >>= 1) {
            var row = model.rows[i];
            row[col] = (byte & 1) ? true : false;
        }
    }
}
//var canvas = document.getElementById('capture');
//var glyph = document.getElementById('glyph');
function captureFont(font)
{
    var cap = new FontCapturer(font, gConfig.targetFontHeight,
        document.getElementById('capture'));
    var models = cap.capture();
    gEditor.load(models);
}

function FontCapturer(font, height, canvas)
{
    this.font = font;
    this.targetFontHeight = height;
    this.canvas = canvas;
    canvas.width = 200;
    canvas.height = 200;
    var ctx = this.ctx = canvas.getContext("2d");
    ctx.font = height +"px "+font;
    this.drawnFontSize = parseInt(ctx.font.match(/(\d+)[^\d]+/)[1]);
    assert(this.drawnFontSize);
}

var capProto = FontCapturer.prototype;

capProto.capture = function()
{
    this.detectFontTop();
    this.detectFontBottom();
    this.drawFontHeight = this.fontBottom-this.fontTop+1;
    this.ratio = this.drawFontHeight / this.targetFontHeight;
    if (this.ratio > 1.0) {
        console.log("Draw font height is not the same as the target one, capturer will scale the image", this.ratio, "times");
    }
    var models = [];
    for (var ch=32; ch < 127; ch++) {
        models.push(this.captureGlyph(String.fromCharCode(ch)));
    };
    return models;
}

capProto.clearCanvas = function() {
    this.ctx.fillStyle = 'white';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = 'black';
}

capProto.drawGlyph = function(ch)
{
    this.clearCanvas();
    var baseline = this.drawnFontSize*2; //make sure we have enought space above the baseline
    this.ctx.fillText(ch, 2, baseline);
    return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
}

var bottomChars = ["g", "j", "p", "q", "y"];
//don't include '|', as it may be the only char that high - we want to use as many rows as possible
var topChars = ["h", "d", "t", "l", "]", "/", "^", "!", "O", "A", "8", "#", "%"];
var medChars = ["x", "v", "w", "z"];

capProto.detectFontBottom = function()
{
    var bottom = 0;
    var len = bottomChars.length;
    for (var i=0; i<len; i++) {
        var data = this.drawGlyph(bottomChars[i]);
        var b = scanBottomBorder(data);
        if (b > bottom) {
            bottom = b;
        }
        console.log('letter', bottomChars[i], 'bottom:', b);
    }
    this.fontBottom = bottom;
}

capProto.detectFontTop = function()
{
    var top = 0xffff;
    var len = topChars.length;
    for (var i=0; i<len; i++) {
        var data = this.drawGlyph(topChars[i]);
        var t = scanTopBorder(data);
        if (t < top) {
            top = t;
        }
    }
    this.fontTop = top;
}

capProto.captureGlyph = function(code)
{
    assert(this.fontBottom);
    assert(this.fontTop !== undefined);
    let ch = String.fromCharCode(code);
    var data = this.drawGlyph(ch);
    //scan width
    var l = scanLeftBorder(data);
    var r = scanRightBorder(data);
    if (l < 0) { //space
        assert(r < 0);
        l = 0;
        r = gConfig.spaceWidth-1;
    }
    var actualWidth = r-l+1;
    data = this.ctx.getImageData(l, this.fontTop, actualWidth, this.drawFontHeight);
    var width = data.width;
    var height = data.height;
    assert(height === this.drawFontHeight);
    var ratio = this.ratio;
    if (ratio > 1.00) {
        this.ctx.putImageData(data, 0, 0);
        while(ratio > 1.0) {
            console.log("iter("+ch+"): height=", height, " ratio=", ratio, "req fontsize:", this.targetFontHeight, "actual:", this.drawFontHeight);
            //select target height that is at most 2 times smaller
            var newHeight = (ratio >= 2.0)
                ? ((height+1)/2)|0 //round upward, so that the ratio is always <=2
                : this.targetFontHeight;
            var iterRatio = height / newHeight;
            assert(iterRatio <= 2.0);
            var newWidth = Math.round(width / iterRatio);
            this.ctx.drawImage(this.canvas, 0, 0, width, height, 0, 0, newWidth, newHeight);
            width = newWidth;
            height = newHeight;
            ratio = height / this.targetFontHeight;
        }
        assert(ratio == 1.0);
        data = this.ctx.getImageData(0, 0, width, height);
    }
    else // not (ratio > 1.0)
    {
        assert(ratio == 1.0);
        console.log("ratio is as expected, height=", height);
    }
    var canv = document.createElement("canvas");
    canv.width = data.width;
    canv.height = data.height;
    canv.getContext("2d").putImageData(data, 0, 0);

    this.ctx.drawImage(this.canvas, 0, 0, data.width, data.height, 0, 0,
        this.canvas.width, this.canvas.height);

    var model = new GlyphModel(data.width, data.height, ch);
    model.loadFromImgData(data);
    return model;
}

function assert(cond) {
    if (!cond)
        throw new Error("assertion failed");
}

function scanRightBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x = w-1; x >= 0; x--)
        for (var y = 0; y<h; y++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return x;
        }
    return -1;
}

function scanLeftBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var x=0; x<w; x++)
        for (var y=0; y<h; y++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return x;
        }
    return -1;
}

function scanTopBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y = 0; y<h; y++)
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return y;
        }
    return -1;
}

function scanBottomBorder(data) {
    var w = data.width;
    var h = data.height;
    data = data.data;
    for (var y=h-1; y>=0; y--) {
        for (var x=0; x<w; x++) {
            if (data[(y*w+x)<<2] < blackThresh)
                return y;
        }
    }
    return -1;
}
class BdfFontParser {
    constructor() {
    }
    parse(contents) {
        let lines = this.lines = contents.split(/[\r\n]/gm);
        let lineCnt = lines.length;
        let models = this.models = [];
        let idx = 0;
        while (idx < lineCnt) {
            let m = lines[idx++].match(/FONTBOUNDINGBOX (\d+) (\d+) ([-\d]+) ([-\d]+)/);
            if (m) {
                this.fontW = parseInt(m[1]);
                this.fontH = parseInt(m[2]);
                this.yNormal = this.fontH + parseInt(m[4]);
                idx++;
                break;
            }
        }
        if (this.fontW == null) {
            throw new Error("No FONTBOUNDINGBOX line found");
        }
        while (idx < lineCnt) {
            for(;;) {
                if (lines[idx].match(/STARTCHAR/)) {
                    break;
                }
                idx++;
                if (idx >= lineCnt) {
                    return models;
                }
            }
            let ret = this.parseGlyph(idx);
            idx = ret[1];
            let model = ret[0];
            if (!model) { // we are not interested in this char
                continue;
            }
            models.push(model);
        }
        return models;
    }
    parseGlyph(idx) {
        var code;
        var xoffs, yoffs;
        let lines = this.lines;
        for (; idx < lines.length; idx++) {
            let line = lines[idx];
            let m = line.match(/([A-Z]+)[\s]*(.*)/);
            if (!m) {
                throw new Error("Cant tokenize line " + line);
            }
            let kw = m[1];
            if (kw === "ENCODING") {
                code = parseInt(m[2]);
                if (code < 32 || code > 191) {
                    return [null, idx+1];
                }
            } else if (kw === "BITMAP") {
                idx++;
                break;
            } else if (kw === "BBX") {
                let values = m[2].split(" ");
                xoffs = parseInt(values[2]);
                let h = parseInt(values[1]);
                yoffs = (this.yNormal - parseInt(values[3])) - h;
            } else if (kw === "ENDCHAR") {
                throw new Error("No BITMAP section");
            }
        }
        if (code == null) {
            throw new Error("No ENCODING section found");
        } else if (xoffs == null) {
            throw new Error("No BBX section found");
        }
        // parse hex values
        let model = new GlyphModel(this.fontW, this.fontH, code);
        while(idx < lines.length) {
            let line = lines[idx++];
            if (line.match(/ENDCHAR/)) {
                return [model, idx];
            }
            let row = model.rows[yoffs++];
            let x = xoffs;
            for (let hexOfs = 0; hexOfs < line.length; hexOfs += 8) { // process 32 bits at a time
                let hexChunk = line.substr(hexOfs, Math.min(line.length - hexOfs, 8));
                let mask = 1 << (hexChunk.length * 4 - 1);
                let bits = parseInt(hexChunk, 16);
                for (; mask; x++, mask >>>= 1) {
                    row[x] = (bits & mask) ? true : false;
                }
            }
        }
        throw new Error("Unexpected end of glyph");
    }
}

function menuLoad(event) {
    event.stopPropagation();
    let rect = document.getElementById("menuLoadBtn").getBoundingClientRect();
    let m = CtxMenu.create();
    m.addItem("BDF file...", null, () => gEditor.importFromBdfFile());
    m.addItem("C source...", null, () => gEditor.importFromCSource());
    m.addItem("Capture font...", null, () => fontSelectGui());
    m.show(rect.left, rect.bottom);
}
function menuSave(event) {
    event.stopPropagation();
    let rect = document.getElementById("menuSaveBtn").getBoundingClientRect();
    let m = CtxMenu.create();
    m.addItem("C source file...", null, () => exportToCSource());
    m.show(rect.left, rect.bottom);
}
function exportToCSource() {
    let name = prompt("Enter font name", gEditor.fontName ? gEditor.fontName.replace(/[^a-zA-Z0-9_]/g, '_') : "MyFont");
    if (!name) {
        return;
    }
    let text = gEditor.exportToCSource(name);
    let blob = new Blob([text], { type: "text/plain" });
    let blobUrl = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = blobUrl;
    a.download = "font_" + gEditor.fontName + ".cpp";
    a.click();
}
/*
<div class=openBtn onclick='fontSelectGui();'>Capture</div>

}
    <input type=file class=file-input onchange='loadLocalFile(event, parseFontCSource);' />

<div class=openBtn onclick='fontSelectGui();'>Capture</div>
}
*/
/*
@font-face {
  font-family: "Kimberley";
  src: url(http://www.princexml.com/fonts/larabie/kimberle.ttf) format("truetype");
}

font-family: "Kimberley", sans-serif;
*/
window.onload = function() {
    loadConfig();
    gEditor = new FontEditor();
}
</script>
</html>
