<html>
<style>
.glyph {
    display: inline-block;
    float: left;
    vertical-align: top;
}
#main {
    display: flex;
    flex-flow: row
}
#menu {
    display: flex;
    flex-flow: row;
    border-bottom: 1px solid #eeeeee;
    flex: 0 0 40px;
}
#pageDiv {
    display: flex;
    flex-flow: column;
    height: 100%;
}
#editorGroup {
    flex: 0 0 auto;
    display: flex;
    flex-flow: column
}
#editor {
   flex: 0 0 auto;
   border: 1px solid #eeeeee
}
#txtPreview, #typingArea {
    flex: 0 0 auto;
    border: 1px solid #eeeeee
}
#lcd {
 height: 128px;
 width:256px;
 background: linear-gradient(to bottom, #f1f7de 0%,#cfd9b0 100%);
 overflow: hidden;
}

#glyphs {
    flex: 1 1 auto;
    display: flex;
    flex-flow: row;
    flex-wrap: wrap;
    align-self: stretch;
    overflow: auto;
    border-left: 1px solid #eeeeee;
}
#spacer {
    flex: 0 0 10px;
}
.glyph {
    flex: 0 0 auto;
    border-right: 1px solid #eeeeee;
    border-bottom: 1px solid #eeeeee;
}
</style>

<script language=javascript>
const kColorFg = "black";
const kColorBg = "white";
function GlyphModel(w, h)
{
    this.width = w;
    this.height = h;
    this.rows = new Array(h);
    for (var r=0; r<h; r++) {
        var row = this.rows[r] = new Array(w);
        for (var c=0; c<w; c++) {
           row[c] = false;
        }
    }
    this.listeners = new Array();
}

GlyphModel.prototype.flip = function(x, y) {
    var row = this.rows[y];
    var val = row[x] = !row[x];
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].updatePixel(x, y, val);
    }
}
GlyphModel.prototype.set = function(x,y,val) {
    var row = this.rows[y];
    var oldVal = row[x];
    if (val === oldVal)
        return;
    row[x] = val;
    var count = this.listeners.length;
    for (var i=0; i<count; i++) {
        this.listeners[i].updatePixel(x, y, val);
    }
}

GlyphModel.prototype.addListener = function(obj) {
    this.listeners.push(obj);
}
GlyphModel.prototype.removeListener = function(obj) {
    var idx = this.listeners.indexOf(obj);
    if (idx < 0)
        return false;
    this.listeners.splice(idx, 1);
    return true;
}
var gDragged = null;

function GlyphView(model, psize, opts)
{
    var self = this;
    self.model = model;
    self.fg = opts.fg || kColorFg;
    self.bg = opts.bg || kColorBg;
    var view = self.widget = document.createElement('table');
    view.style.borderSpacing = 0;
    var rows = model.rows;
    var rowCnt = rows.length;
    var colCnt = rows[0].length;
    for (var y = 0; y < rowCnt; y++) {
        var row = view.insertRow(-1);
        row.style.height=psize;
        var rowData = model.rows[y];
        for (var x = 0; x < colCnt; x++) {
            var cell = row.insertCell(-1);
            //cell.appendChild(document.createTextNode());
            var cellData = rowData[x];
            var style = cell.style;
            style.width=psize;
            style.backgroundColor = cellData ? self.fg : self.bg;
            style.padding = 0;
            var border = opts.border;
            if (border === true) {
                style.border = '1px solid #eeeeee';
            } else if (border) {
                style.border = border;
            } else {
                style.border = '0px';
            }
            cell.x = x;
            cell.y = y;
            if (opts.active) {
                cell.onclick = function(event) {
                    var c = event.target;
                    self.model.flip(c.x,c.y);
                }
                cell.ondragstart = function(event) {
                    // store a ref. on the dragged elem
                    gDragged = event.target;
                    // make it half transparent
                };
                cell.ondragover = function(event) {
                    if (!gDragged)
                        return;
                    var val = (gDragged.style.backgroundColor === self.bg) ? 0 : 1;
                    var target = event.target;
                    self.model.set(target.x, target.y, val);
                }
            }
        }
    }
    model.addListener(self);
}

GlyphView.prototype.updatePixel = function(x,y,val) {
    var row = this.widget.rows[y];
    row.cells[x].style.backgroundColor = val ? this.fg : this.bg;
}

GlyphView.prototype.changeModel = function(model) {
    this.model.removeListener(this);
    this.model = model;
    var h = this.widget.rows.length;
    var w = this.widget.rows[0].cells.length;
    if (h !== model.height || w !== model.width) {
        throw new Error("changeModel: new model has different dimensions");
    }
    for (var y = 0; y < h; y++) {
        var row = this.widget.rows[y];
        var rowData = model.rows[y];
        for (var x = 0; x < w; x++) {
            row.cells[x].style.backgroundColor = rowData[x] ? kColorFg : kColorBg;
        }
    }
    model.addListener(this);
}

var glyphs = [];
var lcdLetters = [];

var gEditor = null;
var glyphCont = null;
window.onload = function() {
    glyphCont = document.getElementById('glyphs');
    var glyphCount = 200;
    for (var i = 0; i < glyphCount; i++) {
        var model = new GlyphModel(8,8);
        var view = new GlyphView(model, 8, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = view.widget;
        widget.model = model; //make the model accessible from the onclick handler
        widget.className = 'glyph';
        glyphs.push(model);
        glyphCont.appendChild(view.widget);
        view.widget.onclick = function(event) {
        gEditor.changeModel(event.currentTarget.model);
        }
    }
    gEditor = new GlyphView(glyphs[0], 32, {active: true});
    document.getElementById('editor').appendChild(gEditor.widget);
    var txtInput = document.getElementById('typingArea');
    txtInput.onkeypress = function(event) {
        var idx = event.keyCode - 32;
        if (idx < 0 || idx >= glyphs.length)
            return;
        var model = glyphs[0]; //[idx];
        var letter = new GlyphView(model, 2, {active: false, bg: 'rgba(255,255,255,0)'});
        var widget = letter.widget;
        widget.style.display = "inline-block";
        lcd.appendChild(letter.widget);
   }
   txtInput.onkeydown = function(event) {
       if (event.keyCode === 8) { //backspace
           var child = lcd.lastChild;
           if (child)
               lcd.removeChild(child);
           return;
       }
   }
}
</script>
<head>
</head>
<body>
<div id=pageDiv>
   <div id=menu>menu</div>
   <div id=main>
     <div id=editorGroup>
       <div id='editor'></div>
       <div align=center>LCD preview:</div>
       <div style="position:relative">
       <div id='lcd'></div>
       </div>
       <textarea id=typingArea></textarea>
     </div>
   <div id= spacer></div>
   <div id= glyphs></div>
 </div>
</div>
</body>
